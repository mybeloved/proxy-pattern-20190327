# 设计模式Demo

## 代理模式


### 定义
    
    为其他对象提供一种代理，以控制对这个对象得访问。代理对象在客户端和目标对象之间起到中介作用，
    代理模式属于结构型模式。使用代理有两个作用，保护目标对象，增强目标对象

### JDKProxy生成对象的步骤

    1、拿到被代理对象的引用，并且通过反射获取到它的所有接口。
    2、JDK Proxy 类重新生成一个新的类，同时新的类要实现被代理类所有实现的所有接口。
    3、动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）。
    4、编译新生成的 Java 代码.class。
    5、再重新加载到 JVM 中运行。   
    
    
#### 为什么JDK动态代理中要求目标类实现的接口数量不能超过65535个？    
    因为在class文件中，接口个数都是用4位16进制表示的，最大值是2的16次方-1 
    
    由于Class文件中方法，字段等都需要引用CONSTAN_Utf8_info型常量来描述名称，
    所以CONSTAN_Utf8_info类型常量的最大长度也就是Java方法，字段名的最大长度。
    而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535.
    所以Java程序中如果定义了超过64KB英文字符的变量和方法名，将会无法编译。
    
    生成的代理类不得超过施加的任何限制在虚拟机的类上。 例如, VM 可能会限制
    类可以实现到65535的接口数;在在这种情况下, {@code 接口} 数组的大小不能
    超过65535。
    
    
### CGLIb

    CGLib 动态代理执行代理方法效率之所以比 JDK 的高是因为 Cglib 采用了 FastClass 机
    制，它的原理简单来说就是：为代理类和被代理类各生成一个 Class，这个 Class 会为代
    理类或被代理类的方法分配一个 index(int 类型)。这个 index 当做一个入参，FastClass
    就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK
    动态代理通过反射调用高
    
    FastClass是在执行MethodProxy invoke\invokeSuper时生成的并放在缓存中。    
    
#### CGLib 和 JDK 动态代理对比

    1.JDK动态代理是实现了被代理对象实现的接口，CGLib是继承了被代理对象
    2.JDK和CGLib都是在运行期生成字节码文件，JDK是直接写Class字节码，CGLib使用了ASM框架
    写Class字节码，CGLib代理实现更复杂，生成代理类比JDK效率低
    3.JDK调用代理方法，是通过反射机制调用，CGLib是通过FastClass机制直接调用方法，CGLib
    执行效率更高    
    
    
## 静态代理和动态的本质区别    

    1.静态代理只能通过手动完成代理操作，如果被代理类增加新方法，代理类需要同步新增，违背开闭原则
    2.动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则
    3.若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类即可，只需要新增策略类
    即可完成，无需修改代理类的方法
    
## 代理模式的优缺点

> 优点
    1.代理模式能将代理对象与真实被调用的目标对象分离
    2.一定程度上降低了系统的耦合，扩展性好
    3.可以起到保护目标对象的目的
    4.可以对目标对象的功能增强

> 缺点
    1.代理模式会造成系统设计中类的数量增加
    2.在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢
    3.增加了系统的复杂度        
    
    
